
---
title: 变量和基本类型

date: 2025-07-24

categories: C++ primer

---
本文为阅读C++ primer第二章的读书笔记，仅作为查找以及防止遗忘对应知识点作用，不可替代原书。

<!--more-->
C++定义了几种基本内置类型，如字符、整型、浮点数等。
# 基本类型
基本内置类型包括算数类型和空类型。算术类型包括字符、整数、布尔值和浮点数。void类型没有关联的值，只能在少数情况下使用，最常见的是作为不返回值的函数的返回类型
## 算术类型
算数类型整体分为整型和浮点型两类。字符和布尔值都属于整型。

C++ 定义了各类型的最小尺寸：bool 未定义、char 8位、short 16位、int 16位、long 32位、long long 64位；float 是 32 位 4 字节，包括6位有效数字、double 是 64 位 8 字节，包括10位有效数字。

> [!NOTE] int位数的特别说明
> int作为一个变长的类型，可能是16位，也可能是32位，取决于编译器。目前多为32位

int、short、long 都是带符号类型。char 是否有符号由编译器决定。

因为 char 是否有符号并不确定，因此可以使用 signed char 或 unsigned char 来指定是否有符号。

C++ 提供了几种字符类型：

1. char：一个 char 的空间应确保可以存放机器基本字符集中任意字符对于的数字值，即一个 char 的大小和一个机器字节一样。
2. wchar_t：宽字符，用于扩展字符集，wchar_t 确保可以存放机器最大扩展字符集中的任意一个字符。
3. char16_t 和 char32_t：为 Unicode 字符集服务。
下为书中列出的表格：
![1158X563/C++_Arithmetic_Types.png](https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250719/ilim/1158X563/C%2B%2B_Arithmetic_Types.png)

> [!NOTE] 类型选择技巧
> 明确知晓数值不可能为负时，选用无符号类型。
> 
> 整数运算用 int，数值太大时用 long long，不用 short 和 long 
> 
> 浮点数运算用 double。float 和 double 的计算代价相差无几
## 类型转换
### 几种类型转换的情况：
- 把浮点数赋给整型时，结果仅保留小数点前的部分。
- 赋给无符号类型超出范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。比如 -1 赋给 8 位 unsigned char 的结果是 255（-1=256*(-1)+255）
- 赋给带符号类型超出范围的值时，结果是未定义的。程序可能工作，可能崩溃。

程序尽量避免依赖于实现环境的行为。比如 int 的尺寸在不同环境可能不同。

### 含有无符号类型的表达式

一个表达式中既有无符号数又有int值时，int会被转换成无符号数。

无符号减无符号数，结果还是无符号数，如果是负值就等于该符数加上无符号数的模
`unsigned u = 10; int i = -42; u + i = -32 + 2^32 = 4294967264`
## 字面值常量
### 整型和浮点型字面值

整型字面值中 0 开头的整数是 8 进制，0x 开头的整数是十六进制。

整型字面值的具体数据类型由它的值和符号决定。默认情况下十进制字面值是带符号数，类型是 int, long, long long 中能容纳当前值的尺寸最小的那个。

浮点型字面值可以用小数或科学计数法表示，科学计数法中的指数部分用 E 或 e 标识
### 字符和字符串字面值
单引号括起来的一个字符是 char 型字面值，双引号括起来的 0 个或多个字符则构成字符串型字面值。

字符串字面值的类型实际上是字符数组，编译器会向每个字符串结尾添加一个空字符（'\0'），因此字符串字面值的实际长度要比它的内容多 1。如 “A” 代表了一个长度为 2 的字符数组。

**如果两个字符串字面值紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。因此字符串比较长时可以直接分行书写**
```cpp
string global_str = "A is B"   "and B is A";
cout << global_str << endl; // 输出: A is Band B is A
```
### 转义序列
建议直接网上查表
### 指定字面值的类型
可以通过给字面值增加前缀和后缀来改变字面值的默认类型。
下为一些常见的字面量类型指定
```cpp
'整型字面值' 
12 // 默认类型为 int 
12u 12U // 最小匹配类型 unsigned 
12l 12L // 最小匹配类型 long 
12ul 12UL // 最小匹配类型 unsigned long 
12ll 12LL // 最小匹配类型 long long 
12ull 12ULL // 最小匹配类型 unsigned long long 
'浮点型字面值' 
3.14 // 默认类型为 double 
3.14f 3.14F // 类型为 float 
3.14l 3.14L // 类型为 long double 
'字符字符串字面值' 
u'a' u"abandon" // Unicode 16 字符，类型为 char16_t 
U'a' U"abandon" // Unicode 32 字符，类型为 char32_t 
L'a' L"abandon" // 宽字符，类型为 wchar_t 
u8"abandon" // 类型为 char，u8 的含义是 UTF-8，仅用于字符串字面值。
```
**注意 12f 是错的，不能给整型字面值加 f 后缀，可以使用 12.f**
# 变量
对于c++而言，”变量“和”对象“一般可以互换使用。

c++中，对象通常指一块能存储数据并具有某种类型的内存
## 变量定义
### 初始化
可以一个一个初始化

也可以在同一条定义语句中使用先定义的变量去初始化后定义的其他变量。
`double price = 109.99, discount = price * 0.6;`

初始化不是赋值，初始化是创建变量时赋予一个初始值，赋值是把对象的当前值擦除并用一个新值来替代。
### 列表初始化
下面四种初始化方式都是可行的，其中使用花括号的方式叫做列表初始化。
```cpp
int i=0; int i={0}; int i{0}; int i(0);
```
当用于内置类型的变量时，使用列表初始化且初始值存在信息丢失的风险，编译器会报错
```cpp
long double ld = 3.1415926536; 
int a{ld}, b={ld}; //错误，存在信息丢失的风险，转换未执行。 
int c(ld), d=ld; //正确
```
### 默认初始化
**定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。**

定义于任何函数之外的内置类型则被初始化为0；

类的对象如果没有显式地初始化，则其由类确定。string 默认初始化为一个空串。

不能使用未初始化的变量，否则会引发运行时故障。

**建议初始化每一个内置类型的变量。**
## 变量声明和定义的关系
声明和定义是严格区分的。

要声明一个变量加 extern，声明变量不能赋值。

任何包含了显式初始化的声明即成为定义。
```cpp
extern int i; // 声明 i 
int i; // 定义i； 
extern int i = 1; // 定义 i，初始化抵消了 extern 的作用。
```
变量只能被定义一次，但是可以多次声明。通过这种方式，一个变量可以在多个文件中使用

声明和定义的区分很重要

c++是静态类型语言，其含义是在编译阶段检查类型。
## 标识符
标识符组成：字母、数字、下划线。不能以数字开头，对大小写敏感。标识符的长度没有限制。

用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。定义在函数体外的标识符不能以下划线开头。这些是为了确保用户自定义的标识符不会和标准库中的重合

变量命名规范：
1. 标识符要体现其实际含义。
2. 变量名一般用小写字母。
3. 用户自定义的类型一般以大写字母开头。
4. 包含多个单词的标识符，使用驼峰命名法或使用下划线连接不同单词。

对于嵌套作用域，可以在内层作用域中重新定义外层作用域已有的名字，但是最好不要这样做。
## 名字的作用域
同一个名字在不同的作用域可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在作用域末端结束
> [!NOTE] 第一次使用变量时定义它
> 有助于更容易找到定义，也可以帮助合理给定初值
### 嵌套的作用域
作用域可以互相包含。

被包含的作用域称为内层作用域（inner scope），包含其他作用域的作用域称为外层作用域（outer scope）。

一旦在作用域中声明了名字，嵌套在该作用域内部的作用域就可以使用该名字。在外层作用域中声明的名称也可以在内层作用域中重新定义。取最近的定义作为访问的对象

> [!NOTE] scope operator
> :: 可以用于在内层访问全局变量

下面是一个例子
```cpp
#include <iostream>

int reused = 42; // reused has global scope
int main(){
	int unique = 0; // unique has block scope
	// output #1: uses global reused; prints 42 0
	std::cout << reused << " " << unique << std::endl;
	
	int reused = 0; // new, local object named reused hides global reused
	// output #2: uses local reused; prints 0 0
	std::cout << reused << " " << unique << std::endl;
	
	// output #3: explicitly requests the global reused; prints 42 0
	std::cout << ::reused << " " << unique << std::endl;
	return 0;
}
```
# 复合类型
复合类型就是基于其他类型定义的类型，引用和指针是其中两种

## 引用
引用是给对象起的别名。初始化引用时，是将引用和对象绑定在一起。引用无法重定向，只能一直指向初始值。

引用必须初始化。引用的初始值必须是一个对象，不能是字面值。引用只能绑定同类型对象。

对引用的所有操作都是对与之绑定的对象的操作。

引用非对象。因此不能定义对引用的引用
## 指针
在块作用域内，指针如果没有被初始化，值将不确定。

指针必须指向指定的类型，不能指向其他类型。**这是严格的，哪怕是long和int都是不能互相指向的**

指针与引用的不同：
- 指针是一个对象而引用不是；
- 指针可以重新赋值，而引用不行
- 有指向指针的指针，无引用的引用
- 指针不需要在定义时赋初值，而引用需要
不能定义指向引用的指针。可以定义指向指针的引用。

> [!NOTE] 根本原因
> 指针是对象，而引用不是、指针指向的是对象，而引用也只能引用对象

### 空指针
```cpp
// 三种定义空指针的方式。最好用第一种
int *p = nullptr;  
int *p = 0; 
int *p = NULL; // NULL 是在头文件 cstdlib 中定义的预处理变量，值为 0。
```

建议初始化所有指针。

非零指针对应的条件值是 ture，零指针对应的条件值是 false。

### void* 指针
void* 指针和空指针不是一回事。

void* 指针是特殊的指针类型，可以存放任意对象的地址。

一般来说，使用 void* 指针将内存作为内存来处理，而不是使用指针来访问存储在内存中的对象

# const限定符
const 对象必须初始化，因为一旦创建就不能再改变值。

默认情况下，const 对象仅在文件内有效。因此你可以在多个文件中定义多个相同名字的const 对象

如果想在多个文件间共享 const 对象，必须在变量的定义前添加 extern 关键字并在本文件中声明。声明和定义都要加 extern。
## 常量引用
常量引用不是说引用是常量，因为引用本来就只能绑定一个对象，而是引用不能改变引用的对象值。

常量引用可以绑定const对象，也可以绑定非常量对象。但是无论哪种，都不能通过引用去修改绑定的对象的值了。

**不能用非常量引用指向一个常量对象。可以用常量引用指向一个非常量对象。**

之前我们提到过：引用的类型必须与其所引用对象的类型一致，但是有两个例外。其中一个例外就是初始化常量引用时允许用任意表达式作为初始值（包括常量表达式），只要该表达式结果可以转换为引用的类型。

> [!NOTE] 原理
> 实际上是创建了一个临时对象让常量引用绑定，也因此不能通过常量引用修改对象的值
## 指针和const
指向常量的指针既可以指向常量也可以指向非常量，和常量引用一样，也不能通过指向常量的指针修改对象的值

至于具体作为常量的指针和指向常量的指针，我们在下一小节介绍
## 顶层const
顶层 const 表示指针本身是个常量，底层 const 表示指针所指的对象是一个常量。顶层 const 对任何数据类型通用，底层 const 只用于引用和指针。

顶层 const 的指针表示该指针是 const 对象，因此必须初始化。底层 const 的指针则不用。

实际上只有指针类型既可以是顶层 const 也可以是底层 const，因为引用实际上只能是底层 const，常量引用即为底层 const，不存在顶层 const 的引用。


**从右向左读来判断是顶层 const 还是底层 const。**

对于指针和引用而言，顶层 const 在右边，底层 const 在左边。对于其他类型，全都是顶层 const

示例如下：
```cpp
const int *const p3 = p2; // 从右向左读，右侧const是顶层const，表明p3是一个常量，左侧const是底层const，表明指针所指的对象是一个常量 
const int* p2 = &c; // 这是一个底层const，允许改变 p2 的值 
int *const p1 = &i; // 这是一个顶层const，不能改变 p1 的值
```

执行对象的拷贝操作时，不能将底层 const 拷贝给非常量，反之可以，非常量将会转化为常量。而顶层const会被忽略。

## constexpr和常量表达式
常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。

字面值属于常量表达式，由常量表达式初始化的 const 对象也是常量表达式。

### cosntexpr变量
在实际应用中很难分辨一个初始值是否是常量表达式，通过将变量声明为 constexpr 类型即可由编译器来检查。

由 constexpr 声明的变量必须用常量表达式初始化。

建议：如果认定一个变量是常量表达式，就把它声明为 constexpr 类型。

新标准允许定义 constexpr，这种函数应该足够简单以使得编译时就可以计算其结果。

不能用普通函数初始化 constexpr 变量，但可以使用 constexpr 函数初始化 constexpr 变量。
### 字面值类型
算术类型、引用、指针都属于字面值类型，自定义类则不属于。

cosntexpr 指针的初始值必须是 nullptr 或 0 或存储于固定地址的对象。函数体之外的对象和静态变量的地址都是固定不变的。

注意区分 constexpr 和 const 。constexpr 都是顶层 const，仅对指针本身有效。
```cpp
const int *p = nullptr; // p 是一个指向整型常量的指针 
constexpr int *q = nullptr; // q 是一个指向整数的常量指针
```
### const和constexpr区别
constexpr 限定了变量是编译器常量，即变量的值在编译器就可以得到。

const 则并未区分是编译器常量还是运行期常量。即 const 变量可以在运行期间初始化，只是初始化后就不能再改变了。

**constexpr 变量是真正的“常量”，而 const 现在一般只用来表示 “只读”。**

# 处理类型
## 类型别名
有以下两种方法
```cpp
typedef double wages; // 使用 typedef 关键字 
using wages = double; // 使用 using 关键字进行别名声明
```
和其他声明语句一样，typedef 的声明语句中也可以包含类型修饰符，从而构造复合类型
```cpp
typedef wages base, *p; // base 是 double 的别名，p 是 double* 的别名。
```

> [!NOTE] 带有指针的别名
> `typedef char* pstring; const pstring cstr = 0;`
>  注意：cstr是一个指向 char 的常量指针。不能采用直接替换的方式将其理解为 const char* cstr = 0，按后者的话，cstr是一个指向常量的指针。这是错误的。
## auto
auto 说明符让编译器根据初始值来分析表达式所属的类型。

auto 可以在一条语句中声明多个变量，但是多个变量将会是同一个基本数据类型

**编译器推断出的 auto 类型有时和初始值并不一样，编译器会进行适当的调整：**
1. auto 根据引用来推断类型时会以引用对象的类型作为 auto 的类型。
2. auto 一般会忽略掉顶层 const，因此对于非指针类型的常量对象，auto 推断出的结果是不含 const 的。如果希望 auto 是一个顶层 const，需要明确指出。
3. auto 会保留底层 const。

下面给出一些例子
```cpp
const int ci = 1, &cr = ci; 
auto b = ci; // b 是一个普通的 int。 
auto c = cr; // c 是一个普通的 int。 
const auto d = ci; // d 是一个 const int 
auto e = &ci; // e 是一个指向常量的引用（常量引用是底层 const）。注意这个微妙的地方。 
auto f = &ci; // f 是一个 const int*（位于左边的 const 是底层 const）
```

**用 auto 定义引用时，必须用 & 指明要定义的是引用**
## decltype类型指示符
当希望获得表达式的类型但是不要计算值的时候，可以使用类型说明符 decltype。

如果 decltype 使用的表达式是一个变量，则它返回该变量的类型（包括顶层 const 和引用在内）。

decltype 与 auto 的不同：decltype 不会忽略引用和顶层 const。

注意当获得的类型是引用时，必须初始化。
### decltype 和引用
如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型。可以使用这种方式来保证不获取引用类型。

注意解引用指针的结果是一个引用类型。给变量加括号的结果也是引用类型。赋值操作的结果也是引用类型。

**decltype((var)) 的结果永远是引用，而 decltype(var) 的结果只有当 var 本身就是引用时才是引用。**
```cpp
int i = 42, &r = i, *p; 
decltype(r+0) b; // b 的类型是 int，因为 r+0 的结果类型是 int。 
decltype(*p) c = i; // c 的类型是 int&。 
decltype((i)) d = i; // d 的类型是 int&。
decltype(j = r+0) b = i; // d 的类型是 int&。
```
# 自定义数据结构和引用
## 定义struct类型
struct+类名+类体+分号。类体可以为空。

`struct Sales_data{}; // 注意：结尾加分号`

定义类时可以给数据成员提供类内初始值以进行初始化。没有类内初始值的成员则被默认初始化。

类内初始值可以放在花括号中或等号的右边，不能使用圆括号。

## 编写自己的头文件
类通常定义在头文件中，类所在头文件的名字应与类的名字一样。

头文件通常定义那些只能被定义一次的实体，比如类、const、constexpr 等。

头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。

### 预处理器概述
确保头文件多次包含仍能安全工作的常用技术是预处理器。

预处理变量有两种状态：已定义和未定义。一般把预处理变量的名字全部大写。

整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。

c++ 中包含三个头文件保护符：

1. #define：把一个名字设定为预处理变量
2. #ifndef：当且仅当变量已定义时为真，一旦检查结果为真，则执行后续操作直到遇到 #endif 为止
3. #endif

预处理变量无视作用域的规则，作用范围是文件内